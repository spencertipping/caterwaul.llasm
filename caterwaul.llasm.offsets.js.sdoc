Offset assembler | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Besides providing mnemonics for machine operations, assemblers (perhaps more importantly) set up your relative offsets correctly. This module provides that functionality for sequences. Given a
sequence with labels (strings) and references (also strings), it removes the strings and sets up the references to point to the correct addresses. Addresses can be relative or absolute, and of
varying sizes and endianness.

Formats.
Label references have several variables. They are:

| 1. Relative vs. absolute offset (sign extension is not used for absolute)
  2. Little vs. big endian encoding
  3. Bit width (8, 16, 32, or 64)

Absolute offsets need a base origin, which you can specify as a parameter to the linker.

  caterwaul.tconfiguration('std seq continuation', 'llasm.offsets', function () {
    this.configure('llasm.struct').namepsace('llasm').offset = offset /se[

The expansion process.
This is kind of delicate. Labels take up space in the initial arrays, so we can't just use the offsets of references to those labels. We first have to get rid of the labels and fill out the
displacement from the addresses, filling them in destructively at the last minute. For example:

| assemble([x81, 

      _.expand(xs) = let*[labels  = {}, mark_label(l, i)     = (labels[l]  || (labels[l]  = [])).push(i),
                          offsets = {}, mark_offset(l, f, i) = (offsets[l] || (offsets[l] = [])).push([i, f]),
                          without_labels = seq[xs %!+is_label]] in
                     seq[~xs *[is_address(_) ? new Array(size_of(_)) : [_]] /~[_ + _0]],
      ],
    where[offset(xs)    = ,
          is_label(x)   = x instanceof String && /^\w+$/.test(x), size_of(x)    = expand_address(x, 0).length,
          is_address(x) = x instanceof String && /^:/.test(x),
          struct        = this.llasm.struct]});
