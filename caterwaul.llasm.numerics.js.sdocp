sdocp('caterwaul.llasm.numerics.js.sdoc', 'Numerical macros | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nJavascript\'s numerical facilities are quite good, but there are some situations for which the notation is suboptimal. In particular, Javascript doensn\'t have great support for low-level bit\nflipping or preserving the byte-size of an integer. This library solves these problems.\n\nNotation.\nYou can specify numbers in either hex or binary by prefixing an even number of hex or binary digits by an \'x\' or \'b\', respectively. (For binary you actually need a multiple of eight digits.)\nThe bit width is encoded with these numbers, as well as little-endian vs. big-endian encoding (by default big-endian encoding is used).\n\n| x08048000             // [0x08, 0x04, 0x80, 0x00]\n  b00100100             // [0x24]\n  xl08048000            // [0x00, 0x80, 0x04, 0x08]\n  xl_0804_80_00         // ditto\n  xaef0                 // [0xae, 0xf0]\n\nFor convenience you can put underscores in the numbers; they get ignored but can visually separate things.\n\nNote that this module requires strings to be numerically indexable, as they are in most places except for IE.\n\n  caterwaul.tconfiguration(\'std seq\', \'llasm.numerics\', function () {\n    this.configure(\'std llasm.struct\').macro(qs[_], fn[x][x && /^[bx]l?[0-9a-f_]{2,}$/.test(x.data) && x.data.replace(/^[xb]l?/, \'\').replace(/_/g, \'\') /re[\n                                                            seq[0 >>>[_ + 1] <<n[n < _.length >> m]] /re.ns[seq[ns *i[_.substring(i, lm)] *~[~_ *+d /[_ * b | _0]]]]\n                                                                                                        /re[le ? _.reversed() : _] /re[new this.ref(_.slice())], unless[_.length & lm - 1],\n                                                            where*[d(x) = \'0123456789abcdef\'.indexOf(x), ca = x.data/mb/charAt, h = ca(0) === \'x\', le = ca(1) === \'l\',\n                                                                   m = 1 + !h * 2, b = h ? 16 : 2, lm = 1 << m]]])});\n');