sdocp('test/itoa.js.sdoc', 'Integer-to-string conversion.\nImplements this logic:\n\n| movl $123456789, %eax\n  .top:\n    xorl %edx, %edx\n    movl $10, %ebx\n    idiv %ebx\n    pushl %eax          ; quotient\n    addl $0x30, %edx    ; remainder + 48 (digit)\n    pushl %edx\n    movl $4, %eax       ; write\n    movl $1, %ebx       ; FD = 1 (stdout)\n    movl %esp, %ecx     ; data is on the stack (little-endian)\n    movl $1, %edx       ; one byte\n    int $0x80\n    popl %edx\n    popl %eax\n    testl %eax, %eax\n    ja .top\n  xorl %ebx, %ebx\n  movl $1, %eax\n  int $0x80\n\ncaterwaul.clone(\'std seq llasm.numerics llasm.elf llasm.asm llasm.struct\')(function (require) {\n  var prelude = qas[xb8 /number.a2l],\n      exit    = qas[x31db, xb8 /xl00000001, xcd80],\n      number  = [\'number\', caterwaul.llasm.struct()._unsigned_int(\'n\')({n: 123456789})],\n      loop    = qas[+top | x31d2, xbb /xl0000000a, xf7fb, x50, x81c2 /xl00000030, x52, xb8 /xl00000004, xbb /xl00000001, x89 /b11_100001\n                         | xba /xl00000001, xcd80, x5a, x58, x85c0, x77 /top[1].r8],\n\n      bytes   = caterwaul.llasm.elf32.trivial_code(caterwaul.llasm.asm(seq[prelude + loop + exit + number], {base: 0x08048000 + 0x54}));\n\n  require(\'fs\') /se.fs[fs.writeFile(\'test/itoa\', new Buffer(bytes.length) /se.bs[seq[bytes *![bs[_i] = _]]], fn_[fs.chmodSync(\'test/itoa\', 0700)])];\n})(require);\n');