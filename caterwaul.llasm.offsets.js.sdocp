sdocp('caterwaul.llasm.offsets.js.sdoc', 'Offset assembler | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nBesides providing mnemonics for machine operations, assemblers (perhaps more importantly) set up your relative offsets correctly. This module provides that functionality for sequences. Given a\nsequence with labels (strings) and references (also strings), it removes the strings and sets up the references to point to the correct addresses. Addresses can be relative or absolute, and of\nvarying sizes and endianness.\n\nFormats.\nLabel references have several variables. They are:\n\n| 1. Relative vs. absolute offset (sign extension is not used for absolute)\n  2. Little vs. big endian encoding\n  3. Bit width (8, 16, 32, or 64)\n\nAbsolute offsets need a base origin, which you can specify as a parameter to the linker.\n\n  caterwaul.tconfiguration(\'std seq continuation\', \'llasm.offsets\', function () {\n    this.configure(\'llasm.struct\').namepsace(\'llasm\').offset = offset /se[\n\nThe expansion process.\nThis is kind of delicate. Labels take up space in the initial arrays, so we can\'t just use the offsets of references to those labels. We first have to get rid of the labels and fill out the\ndisplacement from the addresses, filling them in destructively at the last minute. For example:\n\n| assemble([x81, \n\n      _.expand(xs) = let*[labels  = {}, mark_label(l, i)     = (labels[l]  || (labels[l]  = [])).push(i),\n                          offsets = {}, mark_offset(l, f, i) = (offsets[l] || (offsets[l] = [])).push([i, f]),\n                          without_labels = seq[xs %!+is_label]] in\n                     seq[~xs *[is_address(_) ? new Array(size_of(_)) : [_]] /~[_ + _0]],\n      ],\n    where[offset(xs)    = ,\n          is_label(x)   = x instanceof String && /^\\w+$/.test(x), size_of(x)    = expand_address(x, 0).length,\n          is_address(x) = x instanceof String && /^:/.test(x),\n          struct        = this.llasm.struct]});\n');