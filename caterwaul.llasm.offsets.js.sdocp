sdocp('caterwaul.llasm.offsets.js.sdoc', 'Offset assembler | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nBesides providing mnemonics for machine operations, assemblers (perhaps more importantly) set up your relative offsets correctly. This module provides that functionality for sequences. Given a\nsequence with labels (strings) and references (also strings), it removes the strings and sets up the references to point to the correct addresses. Addresses can be relative or absolute, and of\nvarying sizes and endianness.\n\nFormats.\nLabel references have several variables. They are:\n\n| 1. Relative vs. absolute offset (sign extension is not used for absolute)\n  2. Little vs. big endian encoding\n  3. Bit width (8, 16, 32, or 64)\n\nAbsolute offsets need a base origin, which you can specify as a parameter to the linker.\n\n  caterwaul.tconfiguration(\'std seq\', \'llasm.offsets\', function () {\n    this.configure(\'llasm.struct\').llasm.offset = offset /se[\n\nThe expansion process.\nThis is kind of delicate. Labels take up space in the initial arrays, so we can\'t just use the offsets of references to those labels. We first have to get rid of the labels and fill out the\ndisplacement from the addresses, filling them in destructively at the last minute. For example:\n\n| qas[xc7c3 /top.a2l    // movl .top, %ebx -- absolute 32-bit LE offset encoded as an array of bytes\n     |+top              // .top:\n     |xeb /top[-1].r8]  // jmp .top        -- relative signed 8-bit offset encoded as an array of bytes\n\nHere, the first step is to render the bytestream without labels and where all addresses have the value 0, yielding xc7_c3_00000000_eb_00. Then we fill in the two addresses destructively to\nobtain xc7_c3_00800408_eb_fe.\n\nNote that just as in regular assembly language, labels are global! You need to come up with unique label names unless you want to render your assembly pieces separately and link them somehow.\n\n  Micro-offsets.\n  In the example above, we need to offset the jump pointer by one because the address is positioned after the relative origin. That is, the jump position refers to the number of bytes from the\n  xeb byte rather than the following 8-bit position. So we need to add one to the relative offset since we\'re pointing from one byte behind where the label is.\n\n      _.pre_expand(xs)      = seq[xs -x[x instanceof Array ? _.pre_expand(x) : [x]]],\n      _.expand(xs, options) = let*[base = options.base || 0, labels  = options.labels || {}, mark_label(l, i)     = (labels[l]  || (labels[l]  = [])).push(i)      /re[[]],\n                                                             offsets = {},                   mark_offset(l, f, i) = (offsets[l] || (offsets[l] = [])).push([i, f]) /re[f(0, 0, 0)],\n                                   blanked = let[i = 0] in seq[~xs -[label(_) ? mark_label(_, i) : address(_) /re.a[a ? mark_offset(a.l, a.f, i + a.o) /se[i += _.length] : [_] /se[++i]]]]] in\n                              blanked /se[seq[sp[offsets] *!o[o[1][1](labels[o[0]] || null[\'Reference to undefined label #{o[0]} at offset #{o[1][0]}\'], base, o[1][0]) /se.b[_[i + bi] = b]]]],\n\n      _.encodings = seq[!(~[\'a\', \'r\'] -~r[~[\'8\', \'6\', \'2\', \'4\'] -~s[~[\'\', \'l\'] *e[[\'#{r}#{s}#{e}\', fn[x, base, p][struct.integral(1 << si, ei, !ri)(ri ? x - p : base + x)]]]]])],\n\n  Macro-form.\n  There are two ways to use the assembler. One is to use literal sequences of numbers and strings, and other is to use the qas[] macro, which quotes a section of assembly. The latter has\n  notational advantages, including being able to write unquoted labels and having a concise way to indicate address modes.\n\n      let*[expanders = _.expanders = seq[~[]],                               expander_for = _.expander_for(t) = t && seq[expanders %[t.match(_[0])]][0],\n           def = _.define_expander(p, e) = def /se[expanders.push([p, e])],  expand(t)    = expander_for(t) /re[_ && _[1].apply(this, t.match(_[0])) || t],\n           sub(t, f) = sub /se[def(t, fn[x, y, z][f.replace({x: expand(x), _x: x, y: expand(y), _y: y, z: expand(z), _z: z})])]] in\n\n      sub /se[_(qs[_, _], qs[x.concat(y)])(qs[_ / _], qs[x.concat(y)])(qs[_ | _], qs[x.concat(y)])(qs[~_], qs[_x]),\n              def(qs[_._], fn[x, y][\'#{x.data}:#{y.data}\'])(qs[_[_]._], fn[l, o, f][\'#{l.data}:#{o.data}:#{f.data}\'])(qs[+_], fn[l][l.data /re[/^\\w+$/.test(_) && \'"#{_}"\']]),\n              this.rmacro(qs[qas[_]], expand)]],\n\n    where*[offset(xs, options) = offset.expand(offset.pre_expand(xs), options),\n           label(x)            = x instanceof String && /^\\w+$/.test(x),\n           address(x)          = x instanceof String && /:/.test(x) && let[ss = x.split(/:/)] in {f: _.encodings[ss[0]], l: ss[1], o: Number(ss[2] || 0)},\n           struct              = this.llasm.struct]});\n');